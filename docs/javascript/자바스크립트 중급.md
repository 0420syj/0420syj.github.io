---
sidebar_position: 2
---

# 1. 호이스팅이 왜 필요한지, 개념이 만들어지게 된 배경과 함께 설며왜줘

호이스팅(hoisting)이라는 개념은 JavaScript의 실행 컨텍스트(execution context)와 변수의 선언 및 초기화 방식에 기반합니다. 호이스팅의 필요성과 배경을 이해하려면 JavaScript의 초기 설계 의도와 실행 메커니즘을 살펴볼 필요가 있습니다.

### 호이스팅의 배경

1. **실행 컨텍스트와 변수 초기화**: JavaScript는 코드를 실행하기 전에 실행 컨텍스트를 생성합니다. 이 과정에서 모든 변수와 함수 선언을 미리 읽어들여 해당 스코프의 최상단에 위치시킵니다. 이를 호이스팅이라고 합니다.
2. **함수 선언의 유연성**: 초기 JavaScript 설계에서는 함수 선언의 위치에 관계없이 어디서나 함수를 호출할 수 있는 유연성을 제공하고자 했습니다. 호이스팅은 함수를 선언하기 전에 호출할 수 있게 하여 이러한 유연성을 실현합니다.
3. **변수 선언의 안정성**: 호이스팅은 변수가 선언되기 전에 사용되는 것을 방지합니다. `var`로 선언된 변수는 호이스팅으로 인해 `undefined`로 초기화되며, 이는 선언되지 않은 변수에 접근하는 것보다 안전합니다.

### 호이스팅이 필요한 이유

- **호환성과 일관성**: 호이스팅은 JavaScript의 오래된 기능 중 하나로, 언어의 초기 버전과의 호환성을 유지하기 위해 필요합니다.
- **코드의 유연성 증가**: 특히 함수 호이스팅은 함수를 코드의 어느 곳에서든지 선언하기 전에 호출할 수 있는 유연성을 제공합니다.
- **실행 컨텍스트 이해**: JavaScript의 실행 컨텍스트를 이해하고 예측 가능한 코드를 작성하는 데 중요한 개념입니다.

### 호이스팅의 한계와 현대 JavaScript

- **가독성과 버그**: `var`로 선언된 변수의 호이스팅은 코드의 가독성을 떨어뜨리고, 버그를 일으킬 수 있습니다. 이러한 문제를 해결하기 위해 ES6에서는 `let`과 `const`를 도입했습니다. 이들은 블록 스코프를 가지며, 호이스팅되더라도 TDZ(Temporal Dead Zone)로 인해 선언 전 접근 시 오류를 발생시킵니다.

호이스팅은 JavaScript의 특성 중 하나로, 이를 이해하고 적절히 활용하는 것이 중요합니다. 현대적인 JavaScript 개발에서는 `let`과 `const`를 사용하여 호이스팅으로 인한 혼란을 최소화하는 것이 권장됩니다.

# 2. 실행 컨텍스트에 개념에 대해서 이어서 설명해줘

실행 컨텍스트(Execution Context)는 JavaScript에서 코드가 실행되고 평가되는 환경 또는 범위를 나타냅니다. 실행 컨텍스트는 코드의 실행 순서를 관리하고, 변수, 함수, 객체 등의 정보를 저장하는 데 사용됩니다. JavaScript 엔진은 코드를 실행할 때 실행 컨텍스트 스택을 사용하여 실행 컨텍스트를 관리합니다.

### 실행 컨텍스트의 구성 요소

1. **변수 환경(Variable Environment)**: 변수, 함수 선언, 함수 매개변수 등의 식별자를 저장합니다.
2. **렉시컬 환경(Lexical Environment)**: 변수 환경과 유사하지만, 렉시컬 스코프에 따라 식별자와 관련 정보를 저장합니다.
3. **this 바인딩**: 실행 컨텍스트가 참조하는 `this` 값입니다.

### 실행 컨텍스트의 유형

1. **전역 실행 컨텍스트(Global Execution Context)**:

   - JavaScript 코드가 처음 실행될 때 생성됩니다.
   - 전역 변수와 함수가 여기에 포함됩니다.
   - 전역 객체(window 또는 global)와 연결됩니다.

2. **함수 실행 컨텍스트(Function Execution Context)**:
   - 함수가 호출될 때마다 생성됩니다.
   - 함수 내부의 변수와 매개변수, `this` 값을 포함합니다.

### 실행 컨텍스트의 생성과 실행 과정

1. **생성 단계**:

   - 환경 레코드 생성: 변수, 함수 선언, 매개변수 등의 정보를 수집합니다.
   - 스코프 체인 설정: 현재 컨텍스트와 외부 환경과의 관계를 정의합니다.
   - `this` 값 결정: 실행 컨텍스트에 따라 `this`가 결정됩니다.

2. **실행 단계**:
   - 코드 실행: 함수 내부 또는 전역 코드를 순차적으로 실행합니다.

### 중요성

- 실행 컨텍스트는 JavaScript 엔진이 스코프, 호이스팅, 클로저, `this`와 같은 중요한 특성을 구현하는 방식입니다.
- 코드의 실행 순서와 방식을 이해하고, 스코프 및 변수의 가시성을 관리하는 데 핵심적인 역할을 합니다.

실행 컨텍스트는 JavaScript의 핵심 개념 중 하나로, 코드가 어떻게 실행되고 관리되는지를 이해하는 데 필수적입니다.

# 3. 좀 더 이해하기 쉽게 중요한 내용만 간랴하게 설명해줘

물론입니다. JavaScript의 실행 컨텍스트(Execution Context)는 코드가 실행되는 환경이나 상태를 나타내는 개념입니다. 이를 간단하게 요약하면 다음과 같습니다:

1. **종류**:

   - **전역 실행 컨텍스트**: 코드가 처음 실행될 때 만들어지는, 전역 변수와 함수를 포함하는 환경입니다.
   - **함수 실행 컨텍스트**: 함수가 호출될 때마다 만들어지는, 해당 함수의 변수와 매개변수를 포함하는 환경입니다.

2. **구성 요소**:

   - **변수 환경**: 변수와 함수 선언을 저장합니다.
   - **렉시컬 환경**: 스코프와 관련된 정보를 저장합니다.
   - **this 값**: 실행 컨텍스트에 따라 결정되는 `this`의 값입니다.

3. **과정**:
   - **생성 단계**: 실행 컨텍스트가 생성되며, 변수와 함수 선언을 스캔합니다.
   - **실행 단계**: 코드가 실제로 실행되는 단계입니다.

실행 컨텍스트는 JavaScript 코드가 어떻게 실행되고, 변수와 함수가 어떻게 관리되는지를 이해하는 데 중요한 역할을 합니다. 이 개념을 통해 변수의 스코프, 호이스팅, 클로저 등을 이해할 수 있습니다.

# 4. 렉시컬 환경에 대해서 보충 설명해줘

렉시컬 환경(Lexical Environment)은 JavaScript에서 스코프와 식별자(변수, 함수, 클래스 등)의 관계를 관리하는 내부 메커니즘입니다. 렉시컬 환경은 코드가 작성된 구조를 기반으로 결정되며, 실행 컨텍스트의 주요 구성 요소 중 하나입니다.

### 렉시컬 환경의 구성 요소

1. **환경 레코드(Environment Record)**:

   - 코드에서 선언된 식별자(변수, 함수, 매개변수 등)와 그들의 바인딩(연결된 값)을 저장합니다.
   - 환경 레코드는 선언적 환경 레코드(Declarative Environment Record)와 객체 환경 레코드(Object Environment Record)로 나뉩니다.

2. **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**:
   - 외부 렉시컬 환경에 대한 참조를 저장합니다.
   - 이는 스코프 체인을 형성하는데, 현재 컨텍스트에서 찾을 수 없는 식별자는 외부 렉시컬 환경에서 찾게 됩니다.

### 렉시컬 환경의 중요성

- **스코프 결정**: 렉시컬 환경은 코드의 렉시컬 스코프(정적 스코프)를 결정합니다. 즉, 코드가 작성된 구조에 따라 변수와 함수의 접근성이 결정됩니다.
- **클로저 구현**: 함수가 외부 렉시컬 환경에 대한 참조를 유지함으로써, 클로저가 형성됩니다. 이를 통해 내부 함수가 외부 함수의 변수에 접근할 수 있습니다.

### 예시

```javascript
function outerFunction() {
  let outerVar = "외부 변수";

  function innerFunction() {
    console.log(outerVar); // '외부 변수'
  }

  return innerFunction;
}

const inner = outerFunction();
inner(); // '외부 변수'
```

이 예제에서 `innerFunction`은 `outerFunction`의 렉시컬 환경에 접근할 수 있습니다. 이는 `innerFunction`이 생성될 때, 그 렉시컬 환경이 `outerFunction`의 렉시컬 환경을 참조하기 때문입니다.

렉시컬 환경은 JavaScript의 스코프와 클로저를 이해하는 데 핵심적인 개념으로, 코드의 실행 흐름과 변수의 가시성을 관리하는 데 중요한 역할을 합니다.

# 5. 클로저에 대해서 설명해줘. 앞서 얘기한 컨텍스트와 렉시컬 환경에 대한 얘기와 연계해서 설명해줘

클로저(Closure)는 JavaScript에서 매우 중요한 개념으로, 함수가 자신이 생성될 때의 렉시컬 환경(Lexical Environment)에 대한 참조를 유지하는 현상을 의미합니다. 클로저는 함수와 그 함수가 선언될 당시의 렉시컬 환경의 조합입니다.

### 클로저의 생성

클로저는 다음과 같은 상황에서 생성됩니다:

1. **내부 함수**: 외부 함수 내부에서 정의된 함수입니다.
2. **렉시컬 환경**: 내부 함수는 외부 함수의 변수 등을 포함하는 렉시컬 환경에 대한 참조를 가집니다.
3. **외부에서의 접근**: 내부 함수가 외부로 반환되어 외부 함수의 실행 컨텍스트가 종료된 후에도 해당 함수를 호출할 수 있습니다.

### 클로저의 작동 방식

- **렉시컬 환경의 유지**: 함수가 호출될 때, 해당 함수의 렉시컬 환경은 실행 컨텍스트에 저장됩니다. 내부 함수는 외부 함수의 렉시컬 환경에 대한 참조를 유지하므로, 외부 함수가 실행을 마치고 컨텍스트가 사라진 후에도 외부 함수의 변수에 접근할 수 있습니다.
- **데이터 은닉과 캡슐화**: 클로저를 통해 외부에서 접근할 수 없는 변수를 만들어 데이터를 은닉하고, 특정 함수에 대한 접근을 제한할 수 있습니다.

### 클로저의 예제

```javascript
function createCounter() {
  let count = 0;
  return function () {
    count += 1;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

이 예제에서 `createCounter` 함수는 내부 함수를 반환합니다. 이 내부 함수는 `createCounter` 함수의 렉시컬 환경(여기서는 `count` 변수)에 접근할 수 있습니다. `createCounter` 함수의 실행 컨텍스트가 종료된 후에도, 반환된 내부 함수는 `count` 변수에 접근하여 값을 변경하고 반환할 수 있습니다. 이것이 바로 클로저의 핵심입니다.

### 중요성

- 클로저는 함수형 프로그래밍에서 매우 중요한 역할을 합니다.
- 상태를 안전하게 은닉하고, 메모리 내에 데이터를 유지할 수 있게 해줍니다.
- 클로저는 JavaScript의 핵심적인 특성으로, 모듈 패턴, 고차 함수, 콜백 등 다양한 곳에서 활용됩니다.
